.. _storage_and_query:

************************************************** **********
Хранение и запрос
************************************************** **********

Обзор
----------------------------------------

**В отличие от других блокчейнов, где адреса являются публичными ключами или их хэшами, адресное пространство RChain будет структурированным.** . Тем не менее, за кулисами уровень хранилища и запроса полностью децентрализован и подчиняется согласованному алгоритму. В соответствии с возможностями микро транзакций, присущими решениям blockchain, пользователи dApp на RChain платят за ресурсы (вычисление, память, хранение и сеть), используя токены. Конструкция RChain считает, что все хранилища «сохраняются», хотя не все данные будут сохранены навсегда. Вместо этого хранилище данных будет сдано в аренду и будет стоить производителям этих данных пропорционально его размеру, сложности и продолжительности аренды. Потребителям также может потребоваться оплатить доступ к поиску. Производители и потребители данных опосредованно платят операторам узлов.

Простая экономическая причина, оправдывающая лизинг, заключается в том, что хранение должно быть оплачено кем-то; иначе он не может быть надежно сохранен или «вечен». Мы решили сделать экономический механизм прямым. Индустриально недружественная идея заключается в том, что хранение становится «бесплатным» только для субсидирования его несвязанным процессом. Малая часть реальной стоимости измерима в сигнатурах дата - центров обработки данных, которые растут до ошеломляющего размера. Эта стоимость данных по мере их доступа также помогает уменьшить «атакующее» хранилище, а также хранение незаконного контента для дискредитации технологии.

Поддерживается множество данных, включая общедоступные незашифрованные json, зашифрованные BLOB или микс. Эти данные также могут быть простыми указателями или хеш- контентами, ссылающимися на внеплатформенные данные, хранящиеся в частных, публичных или консорциусных местоположениях и форматах.

Семантика данных
----------------------------------------

Блок-схема RChain будет хранить состояние, локальную историю транзакций и связанные с ним продолжения контракта. Как и Ethereum, блок-схема RChain также реализует криптоэкономически поддающуюся проверке транзакционную семантику для создания линейной временной истории вычислений, выполняемой на платформе. Обратите внимание, что математика, лежащая в основе этой семантической структуры цепочки, называется Traced Monoidal Category. Более подробно см. Статью Масахито Хасегавы по этой теме «Рекурсия из циклического обмена: прослеживаемые моноидальные категории и модели циклических лямбда-калькулов».

.. _Recursion from Cyclic Sharing: Отслеживаемые моноидальные категории и модели циклических вычислений Лямбда: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.52.31&rep=rep1&type=pdf

============================================
Уровень доступа к данным и специфичный доменный язык
============================================

SpecialK - DSL для доступа к данным, а KVDB - структура данных распределенной памяти за DSL. SpecialK определяет распределенные шаблоны доступа к данным согласованным образом, как показано ниже:

.. table :: Figure - Шаблоны доступа к данным SpecialK

+ --------------------------- + --------------------- -------------------------------- + ----------------- ------------ + ----------------------------------- + - ------------------------------------- +
| | ** Чтение и запись на уровне предметов (распределенная блокировка) ** | ** Чтение и запись базы данных ** | ** Публикация / Подписка на сообщения ** | ** Публикация / Подписка с историей ** |
+ =========================== + ===================== ================================ + ================= ============ + =================================== + = ===================================== +
| ** Данные ** | Эфемерные | Стойкие | Эфемерные | Стойкие |
+ --------------------------- + --------------------- -------------------------------- + ----------------- ------------ + ----------------------------------- + - ------------------------------------- +
| ** Продолжение (K) ** [#] _ | Эфемерные | Эфемерные | Стойкие | Стойкие |
+ --------------------------- + --------------------- -------------------------------- + ----------------- ------------ + ----------------------------------- + - ------------------------------------- +
| ** Производственный глагол ** [#] _ | Положить | Магазин | Опубликовать | Опубликовать с историей |
+ --------------------------- + --------------------- -------------------------------- + ----------------- ------------ + ----------------------------------- + - ------------------------------------- +
| ** Потребительский глагол ** | Получить | Читать | Подписаться | Подписаться |
+ --------------------------- + --------------------- -------------------------------- + ----------------- ------------ + ----------------------------------- + - ------------------------------------- +


* Рисунок - Шаблоны доступа к данным SpecialK *

С точки зрения SpecialK DSL и API, когда он выполняет действие по доступу к данным, такое как глагол Get (с шаблоном), безразлично, хранятся ли эти данные локально или удаленно, т.е. в какой-либо другой сети узел. Существует единственный механизм запроса независимо.

Технологический стек 2016 года и предшествующий SpecialK (Agent Services, SpecialK и KVDB с RabbitMQ и MongoDB) поставляли децентрализованную сеть доставки контента, хотя она не была ни измерена, ни монетизирована. Компоненты SpecialK & KVDB располагаются поверх MongoDB и расширенного протокола очереди сообщений (ZeroMQ изучается) для создания децентрализованной логики для хранения и извлечения контента как локально, так и удаленно. Текущие версии 1.0 SpecialK и KVDB написаны на Scala и находятся в `GitHub`_.

.. _GitHub: https://github.com/leithaus/SpecialK

Семантика запроса изменяется в зависимости от того, какой уровень в архитектуре задействован. На уровне SpecialK ключи представляют собой прологовые выражения, которые позже запрашиваются через выражения datalog. В архитектуре используются расширенные выражения меток, а для запроса используются выражения меток datalog. В RChain уровни SpecialK и KVDB будут повторно реализованы в Rholang (по сравнению с предыдущей реализацией в Scala с пользовательской реализацией разграниченных продолжений и сериализации кода).

Для получения дополнительной информации см. «SpecialK & KVDB`_ - язык шаблонов для Интернета.

.. _SpecialK & KVDB: https://docs.google.com/document/d/1aM5OIJWOyW89rHdUg6d9-YVbItdtxxiosP_fXZQaRdg/edit

================================================== ===
KVDB - доступ к данным и продолжению, кэш
================================================== ===

Доступ к данным будет осуществляться с помощью семантики SpecialK, в то время как физически хранится в децентрализованной базе данных Key-Value, известной как «KVDB». Ниже показано, как два узла взаимодействуют для ответа на запрос получения:


.. figure :: ../img/specialk.png
  : align: center
  : ширина: 3446
  : шкала: 25

  * Рисунок - Децентрализованный доступ к данным в SpecialK *


1) Сначала узел запрашивает свой кеш в памяти для запрошенных данных. Тогда, если он не найден,

2) запрашивает его локальное хранилище и, если он не найден, сохраняет разграниченное продолжение в этом месте и

3) запрашивает сеть. Если и когда сеть вернет соответствующие данные, разграниченное продолжение вернется в область видимости с выбранными данными в качестве параметра.

Почему RChain не выбрал IPFS ((InterPlanetary File System) для распределенной памяти? В дополнение к рискам централизации IPFS использует путь для доступа к контенту, тогда как SpecialK использует целые деревья (и деревья с дуплом в них) для доступа к контенту. IPFS имеет интуитивную модель пути, но этот дизайн задает вопрос о том, как выполнять запросы. SpecialK запускается со стороны запроса. Теперь проект RChain может извлечь выгоду из работы IPFS, включая их хеширование для адресации контента, как только семантика запроса SpecialK будет на месте. SpecialK также может использовать случайно сгенерированный плоский ключ, который не имеет корреляции с данными.

Связь P2P-узла
---------------------------------------------

Как и в других децентрализованных реализациях, этот компонент отвечает за обнаружение узлов, обеспечение доверия между узлами и обработку сообщений между ними.Появится несколько протоколов на уровне платформы, которые будут обеспечивать безопасность, доверие между узлами и обработку сообщений между ними.

.. [#] Обратите внимание, что по соглашению функция продолжения представляется как параметр с именем k.
.. [#] Это только подмножество глаголов, доступных при этом разложении функциональности. Например, выбор из глагола получает данные, не оставляя продолжения вокруг, если данных нет.

