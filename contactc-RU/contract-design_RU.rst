.. _contract-design:

************************************************** ****************
Дизайн контрактов
************************************************** ****************

Контракт на RChain представляет собой хорошо специфицированную и удобную для анализа программу, которая может взаимодействовать с другими. Пользователи и другие контракты взаимодействуют с ним при помощи транзакций.

Данный раздел описывает необходимые требования для децентрализованного параллельного исполнения приложений, а также вычислительные модели и языки программирования, которые наилучшим образом их удовлетворяют. Здесь мы познакомимся с языком Rholang – языком, описывающим поведенческие типизированные, рефлективные процессы высшего порядка (behaviorally typed, reflective, higher-order process language).

Обзор контракта
================================================== ====================================

Используется свободно как «контракт» **, умный контракт - это процесс с: **

1. Постоянным состоянием
2. Связанным кодом
3. Связанным адресс (ом) RChain

Важно помнить, что умный-контракт имеет произвольную сложность. Он может ссылаться на маленькую операцию или на множество протоколов, которые составляют общий сложный протокол.

Контракт инициируется сообщением от внешнего сетевого агента, где внешним агентом может быть контракт или пользователь сети.

**Сообщение:**

1. Выдается по именованному каналу (каналам), который может быть открытым или закрытым.
2. Может быть напечатан и может варьироваться в формате от простого значения до неупорядоченного массива байтов, к переменной, к структуре данных, к * коду процесса * и большинству вещей между ними.

** Агент ** отправляет и принимает сообщения по именованным каналам связи, известным как «именованные каналы».

** Именованный канал: **

1. «Местоположение», где синхронизируются независимые процессы.
2. Используется процессами для отправки и получения сообщений между собой.
3. Является предположительно неопознанным и анонимным, если это не преднамеренно введено процессом.

Канал реализуется как переменная, которая разделяется между процессом «только для чтения» и «только для записи». Поэтому функциональность канала ограничивается только интерпретацией того, что может быть переменной. Поскольку канал представляет абстрактное понятие «местоположение», он может иметь разные формы. Для нашей ранней интерпретации функция именованного канала может варьироваться от локального адреса (переменной) отдельной машины до сетевого адреса машины в распределенной системе.

В соответствии с этой интерпретацией ** адрес блокчейна является именованным каналом **, то есть местоположением (местами), где может быть достигнут агент.

Два контракта, отправляющих и получающих сообщение по каналу с именем «Адрес»:


.. figure :: ../img/57444266.png
   : ширина: 844
   : align: center
   : шкала: 60



Эта модель изображает два контракта, оба из которых могут принимать и отправлять сообщения. В какой-то момент внешнему участнику предлагается: code: `Contract1` отправить значение,: code:` v`, на канал,: code: `address`, который является адресом: code:` Contract2`. Между тем: code: `Contract2` прослушивает: код:` address` канал для некоторого значения: code: `v`. После получения: code: `v`,: code:` Contract2` вызывает продолжение процесса с: code: `v` в качестве аргумента. Эти последние два этапа происходят последовательно.

Обратите внимание, что эта модель предполагает, что, по крайней мере, отправитель имеет адрес: code: `Contract2`. Также обратите внимание, что после его отправки: код: `v`,: code:` Contract1` был запущен до завершения, поэтому он не может отправлять что-либо еще, если не будет запрошено. Аналогично, после того, как он вызывает его продолжение, код: `Contract2` был запущен до завершения, поэтому он не может прослушивать какие-либо другие сообщения.

Контракты RChain имеют мелкозернистую внутреннюю одновременность, что означает, что эти процессы и любые процессы, которые не являются зависимыми друг от друга, могут быть размещены параллельно. Итак, мы вносим изменения в наши обозначения:


.. figure :: ../img/82846984.png
   : align: center
   : ширина: 926
   : шкала: 60



Выполняя параллельно с несколькими другими процессами, внешний субъект запрашивает: code: `Contract1` для отправки значения,: code:` v`, на канал: code: `address`, то есть адрес: code:` Contract2 `. Если: code: `Contract1` не имеет значения для отправки, он блокирует. Если: code: `Contract2` не получил значение, он блокирует и продолжение не запускается.

операции
-------------------------------------------------- -----------

Как семантика транзакций вписывается в наше описание контрактов? ** С уровня процесса транзакция является подтверждением того, что сообщение было «засвидетельствовано» на канале **

Сами сообщения являются виртуальными объектами, но предварительное состояние и пост-состояние контракта, ссылаясь на завления до и после сообщения, отправляются одним агентом и засвидетельствованы другим, записываются и помещаются в хранилище, также известное (в общем смысле) как «блокчейн».

Передача сообщений - это мельчайшая операция. Несмотря на засвидетельствование сообщения или нет,  только успешная проверка сообщения квалифицируется как проверяемая транзакция, которая может быть включена в блок. Примеры до настоящего времени описывают атомные протоколы, но полнофункциональные приложения могут появляться, отправлять и получать по десяткам тысяч каналов во время выполнения. Следовательно, когда значение какого-либо ресурса изменяется и засвидетельствовано процессом, есть запись того, когда и где он был засвидетельствован каким-то агентом. Эта реализация согласуется с интерпретацией данных как линейного ресурса.


.. figure :: ../img/10156345.png
   : align: center
   : ширина: 918
   : высота: 460
   : шкала: 60


Возможность отправки сообщения на любом конце канала до и после отправки сообщения и, следовательно, для просмотра сериализованной формы сообщений, является атрибутом, специфичным для RChain. Кроме того, путем указания успешных сообщений как транзакций, учитываются все сообщения, будь то от внешнего пользователя до контракта или между контрактами. Таким образом, мы уравновешиваем расширяемую автономию контрактов с подотчетностью.

Для примера того, как эта модель адаптируется к отраслевым тенденциям в реактивном программировании, обратите внимание на следующие два контракта, которые моделируют взаимодействие по «живым» каналам данных:


.. figure :: ../img/21300107.png
   : ширина: 1014
   : высота: 142
   : align: center
   : шкала: 50


Выполняя параллельную компоновку с рядом других процессов: code: `Contract1` предлагается отправить набор значений: code:` vN`, на канал: code: `address`, то есть адрес: code:` Contract2`. В этом случае читатель заметит: code: `Contract2` как поток, который прослушивает набор значений в качестве входных данных из одного потока данных, который является двойным для набора значений, выводимых из потока по его хвосту. Когда на канале засвидетельствован набор значений: code: `v1 ... vN`,: code:` address`, продолжение вызывается с помощью: code: `v1 ... vN` в качестве аргумента. В то время как взаимодействие между: code: `Contract1` и: code:` Contract2` является асинхронным, операция ввода: code: `address? (V1 ... vN)` и: code: `Continuation (v)` of: code : `Contract2` обязательно последовательны. : code: `address? (v1 ... vN)` называется «pre-fix»: code: `Continuation (v)` в каждом экземпляре.

Мы представили очень подробное описание многозадачного взаимодействия с контрактом на платформе RChain для включения контрактов, распознанных адресом в качестве канала связи и транзакцию в качестве успешной передачи сообщения по указанным каналам. Затем мы изложим основную систему, которая формально моделирует эти конструкции.

Формализм: Rho-Исчисление
================================================== ===============

Формальная проверка является стандартом * де-факто * для многих критически важных технологий. Некоторые из ранних формальных методов проверки были применены к двухуровневым системам выключения ядерных генераторов [#] _. Многие программные решения ATM подтверждают эффективность, выбирая решения из моделей линейной временной логики. Многие военные системы информации и принятия решений ссылаются на логику Хоар для проверки устойчивости к сбоям. Неизбирательная интеллектуальная контрактная утилита, которая желает принять важные для нее контракты, несет ту же ответственность за проверяемость своих пользователей. Поэтому наш проектный подход к модели поверхностного языка и исполнения основан на доказуемо правильной модели расчета [#] _.

В то же время существует относительно мало программных парадигм и языков, которые обрабатывают параллельные процессы в своей базовой модели. Вместо этого они запирают какую-то модель параллелизма на основе потоков на стороне, чтобы обращаться к возможности масштабирования, делая больше чем одно за раз. Напротив, калькуляция мобильных процессов обеспечивает принципиально иное представление о том, каковы вычисления. В этих моделях вычисления возникают в основном из взаимодействия процессов. Способность формально проверять модель исполнения и разрешить эту модель исполнения принципиально параллельна, поэтому мы выбрали исчисление процесса для модели вычисления RChain.

В частности, ** модель исполнения RChain получена из синтаксиса и семантики rho-исчисления. ** Ро-исчисление представляет собой вариант π-исчисления, который был введен в 2004 году для обеспечения первой модели одновременных вычислений с отражением. «Rho» означает рефлексивный, более строгий порядок.

Хотя понимание π-исчисления не является необходимым для целей настоящего документа, тем, кто не знаком с π-исчислением, настоятельно рекомендуется изучить его. Π-исчисление - это первая формальная система, позволяющая успешно моделировать сети, где узлы могут регулярно присоединяться и выходить из сети. Он предполагает мелкозернистую параллельность и обработку процесса, то есть два процесса могут быть введены третьим процессом. Расширение rho-calculus наследует все эти функции и добавляет свое.

Дополнительную информацию см. В разделе «Полиадикальное Pi-Calculus` и« Модели более высоких категорий Pi-Calculus ».

.. _ Полиадическое Pi-Исчисление: http://www.lfcs.inf.ed.ac.uk/reports/91/ECS-LFCS-91-180/
.. _Higher Категория Модели Pi-Исчисления: https://arxiv.org/abs/1504.04311

отражение
-------------------------------------------------- ---------------------

Отражение в настоящее время широко признается как ключевая особенность практических языков программирования, широко известная как «мета-программирование». Отражение - это дисциплинированный способ превратить программы в данные, которые могут работать на программах, а затем превращать измененные данные в новые программы. Java, C # и Scala в конечном итоге приняли отражение в качестве основной функции, и даже OCaml и Haskell в конечном итоге разработали отражающие версии [#] _. Причина проста: в промышленном масштабе программисты используют программы для написания программ. Без этого вычислительного рычага потребовалось бы слишком много времени для написания передовых программ промышленного масштаба.


Синтаксис и семантика
-------------------------------------------------- ------------------------
Ро-исчисление строит «имена» и «процессы». Подобно π-исчислению **, имя может быть каналом связи или значением. Однако при добавлении rho-исчисления «отражение» имя может также быть «цитируемым» процессом, где цитируемый процесс является кодом процесса. ** Общая характеристика имен станет важной в следующих разделах.

Из понятия имен и процессов в исчислении строятся несколько основных «процессов». Процесс может иметь постоянное состояние, но не предполагает его. Термин «процесс» является более общим термином для «умного контракта». Следовательно, каждый контракт - это процесс, но не каждый процесс - это умный контракт.

Rho-calculus строит следующие основные термины для описания взаимодействия между процессами:

::

  P, Q, R :: = 0 // ниль или остановленный процесс

            | для (ptrn1 <- x1; ...; ptrnN <- xN) .P // вход защищенного процесса
            | x! (@Q) // вывод
            | \ * x \ // разыменованное или неуказанное имя
            | P | Q // параллельный состав

  x, ptrn :: = @P // имя или цитируемый процесс


Первые три слова обозначают I / O, описывающие действия передачи сообщений:

*: code: `0` является формой инертного или остановленного процесса, который является основанием
  модели.

* Входной термин,: code: `for (ptrn1 <- x1; ...; ptrnN <- xN) P`, является формой
  вход-охраняемым процессом,: код: `P`, прослушивание набора шаблонов,: code:` ptrnN`,
  по набору каналов: код: `xN`. При получении такой картины продолжение P
  вызывается [#] _. Программисты Scala заметят «понимание» как
  синтаксический сахар для обеспечения доступа к каналу монадически [#] _. В результате
  все входные каналы подлежат сопоставлению с образцом, который создает
  входную защиту

* Термин выхода: код: `x! (@Q)`, отправляет имя,: code: `@ Q`, на канал: code:` x`. Хотя имя, отправленное на: code: `x`, может быть значением, каналом или цитированным процессом (который может содержать много каналов и значений), наши обозначения используют: code:` @ Q`, чтобы подтвердить выразительность имен.

Следующий термин является структурным, описывающим параллелизм:

*: code: `P | Q` - это форма процесса, который является параллельным составом двух процессов P и Q, где оба процесса выполняются и сообщаются асинхронно.

Для обеспечения рефлексии вводятся два дополнительных условия:

*: code: `@ P`, термин« Отражение »вводит понятие« цитируемого процесса », который является кодом процесса, который сериализуется и отправляется по каналу.

*: код: `x`, термин« Отожоствление», разрешает десериализацию цитируемого процесса из канала.

Этот синтаксис дает основной язык терминов, который будет содержать примитивы системы типа Rholang.
Ро-исчисление предполагает внутреннюю структуру имен, которая сохраняется, поскольку они передаются между процессами. Одним из результатов исследования внутренней структуры имени является то, что процессы могут быть сериализованы на канал и затем десериализованы при приеме, что означает, что процессы могут не только передавать сигналы друг другу, они могут передавать процессы полной формы в друг друга. Следовательно, расширение более высокого порядка.

Rho-calculus также дает единое правило сокращения (замены) для реализации вычисления, известного как правило «COMM». Редукции являются атомными; они либо происходят, либо нет. Это единственное правило, непосредственно уменьшающее термин rho-calculus:

.. code-block :: none

  для (ptrn <- x) .P | x! (@ Q) -> P {@ Q / ptrn} // Правило сокращения

Правило COMM требует, чтобы два процесса были помещены в параллельное выполнение. Это также требует, чтобы эти два были связаны между собой. То есть, один процесс читает с канала,: code: `x`, а другой процесс записывает на канал: code:` x`. Говорят, что два процесса «синхронизируются» по адресу: code: `x`. Процесс вывода отправляет цитируемый процесс: code: `@ Q`, on: code:` x`. Параллельно процесс ввода ожидает произвольного шаблона: code: `ptrn`, чтобы прибыть: code:` x`. После сопоставления шаблона он выполняет продолжение: code: `P`. После сокращения упрощенный термин обозначает: code: `P`, который будет выполняться в среде, где: code:` @ Q` привязан к: code:`ptrn`. То есть: code: `@ Q` заменяется на каждое вхождение: code:` ptrn`, в теле: code: `P`.

Правило COMM означает успешное сообщение сообщения по каналу. Читатель может помнить, что успешная связь сообщений по каналу представляет собой проверяемую транзакцию. Фактически, ** сокращение - это транзакция ** именно потому, что она проверяет, что доступ к ресурсу был изменен. В результате ** количество выполненных сокращений соответствует единицам выполненных атомных вычислений, которые в основном привязаны к количеству транзакций, совершаемых блоком. ** Это соответствие гарантирует, что вычисление всей платформы будет количественно поддаваться правильной оценке.

Еще одним следствием того, что можно исследовать внутреннюю структуру имени, является то, что каналы могут инкапсулировать еще больше каналов. Хотя они очень легки в атомном смысле, когда каналы обладают внутренней структурой, они могут функционировать как хранилища данных, структуры данных и, возможно, неограниченные очереди произвольной глубины. Фактически, почти во всех реализациях постоянное хранилище контракта будет состоять из значения состояния, хранящегося в канале: code: `state`, который принимает запросы: code:` set` и: code: `get` a: code:` newValue `. Мы продемонстрируем широкомасштабные последствия внутренней структуры на каналах в разделе на пространствах имен. Более подробную информацию см. В разделе «Аспективное вычисление высших порядков» и «Логика пространств имен» - логика для рефлексивного вычисления высших порядков`_.

.. _A Светоотражающее исчисление высших порядков: http://www.sciencedirect.com/science/article/pii/S1571066105051893
.. _Namespace Logic - Логика для рефлексивного вычисления высших порядков: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.95.9601

Поведенческие типы
-------------------------------------------------- -

Поведенческий тип является свойством объекта, который привязывает его к дискретному диапазону шаблонов действий. Поведенческие типы ограничивают не только структуру ввода и вывода, но ** разрешенный порядок входов и выходов среди сообщающихся и (возможно) параллельных процессов в различных условиях. **

Поведенческие типы специфичны для исчислений мобильных процессов, в частности, из-за отсутствия детерминизма, который внедряют и обслуживают мобильных исчеслений. Более конкретно, параллельная модель может вводить несколько сценариев, по которым можно получить доступ к данным, но не владеющих информацией о последовательности, в которой происходят эти сценарии. Данные могут быть разделены на определенные этапы протокола, но не на следующем этапе. В этом смысле ресурсная конкуренция является проблематичной; если система не учитывает точные ограничения обмена на объекты, могут возникнуть мутации. Поэтому мы требуем, чтобы сетевые ресурсы использовались в соответствии со строгой дисциплиной, которая описывает и определяет наборы процессов, которые демонстрируют подобное «безопасное» поведение.

Система поведенческого типа Rholang будет итеративно украшать термины модальными логическими операторами, которые являются предложениями о поведении этих терминов. В конечном итоге поток данных данных свойств, доступ к ресурсам будет конкретизирован в системе типов, которая может быть проверена во время компиляции.

Системы поведения, которые Rholang будет поддерживать, позволяют оценивать подборки контрактов по отношению к тому, как формируется их код и как он ведет себя. Таким образом, Rholang-контракты повышают семантику до точки доступа на уровне типа, где мы можем рассчитать, как целые протоколы могут безопасно взаимодействовать.

В своей оригинальной статье «Логика как распределительный закон» Майк Прести и Григорий Мередит разработали алгоритм, позволяющий итеративно генерировать логику пространственно-поведенческого характера из любой монадической структуры данных.

.. _Logic как распределительный закон: https://arxiv.org/pdf/1610.02247v3.pdf

Значение
=================================================

За последние десять лет эта модель неоднократно рассматривалась экспертами. Прототипы, демонстрирующие его обоснованность, доступны уже почти десять лет. Минимальный синтаксис rho-calculus выражает шесть примитивов - намного меньше, чем в Solidity,  языке умных контрактов Ethereum, но модель гораздо более выразительна, чем Solidity. В частности, смарт-контракты на основе Solidity не пользуются внутренним параллелизмом, в то время как контракты на основе Rholang предполагают это.

Подводя итог, формализм rho-calculus является первой вычислительной моделью по :

1. Реализации максимальной мобильности кода с помощью «отражения», что позволяет передавать полноразмерные цитируемые процессы в качестве первоклассных  другим сетевым процессам.

2. Запуску основ для математической проверки поведения рефлексивных, коммуникационных процессов и принципиально параллельных систем динамической сетевой топологии.

3. Обозначению полного масштаба конструкции, которая естественным образом учитывает тенденции отрасли в структурном сопоставлении моделей, продолжении процесса, реактивном API, параллелизме, асинхронности и поведенческих типах.

RhoLang - параллельный язык
================================================== =======

Rholang - полнофункциональное, универсальное, полное программирование Turing
языка, построенное на rho-исчисления. Это поведенческая типизация, ** r ** - eflective,
** h ** - higher ** o ** - rder process language и официальный интеллектуальный язык контрактов
от RChain. Его цель - конкретизировать мелкозернистый программный параллелизм.

Обязательно, язык ориентирован на параллелизм, с акцентом на передачу сообщений через входные каналы. Каналы статически типизированы и могут использоваться как отдельные каналы сообщений, потоки или хранилища данных. Подобно типизированным функциональным языкам, Rholang будет поддерживать неизменные структуры данных.

Чтобы получить удовольствие от Rholang, вот контракт под названием: code: `Cell`, который имеет значение и позволяет клиентам получить и установить его:

.. code-block :: none

   Контракт Ячейка (get, set, state) = {
     Выбрать {
       случай rtn <- get; v <- state => {
         rtn! (* v) | состояние! (* v) | Ячейка (get, set, state)
       }
    
       case newValue <- set; v <- state => {
         состояние! (* newValue) | Ячейка (get, set, state)
       }
     }
   }

Этот контракт берет канал для: кода: `get` запросов, канала для: кода:` set` запросов и канала: code: `state`, где мы будем хранить ресурс данных. Он ждет по кодам: `get` и: code:` set` каналы для клиентских запросов. Запросы клиентов соответствуют шаблону через: code: `case` classes [#] _.

По получении запроса в договор включается: код: `;` входящий клиент с запросом на канал: code: `state`. Это объединение делает две вещи. Во-первых, он удаляет внутреннее: code: `state` от доступа, в то время как это, в свою очередь, секвенирует: код:` get` и: code: `set`, так что они всегда работают против одной согласованной копии ресурса - одновременное предоставление механизма синхронизации ресурсов данных и памяти обращений и обновлений к: code: `state`.

В случае: code: `get`, запрос приходит с адресом: code:` rtn`, где будет отправлено значение,: code: `v`, in: code:` state`. Поскольку: код: `v` был взят из канала: code:` state`, он помещен обратно, а поведение: code: `Cell` рекурсивно вызывается.

В случае: code: `set`, запрос приходит с: code:` newValue`, который публикуется по каналу: code: `state` (старое значение, которое было украдено соединением). Между тем, поведение: code: `Cell` рекурсивно вызывается.

Подтвержден: код: `select`, только один из потоков в: code:` Cell` может отвечать на запрос клиента. Это гонка, и потерянная нить, будь то геттер или сеттер, убита. Таким образом, когда вызывается рекурсивный вызов: code: `Cell`, потеряющий поток не висит вокруг, но процесс new: code:` Cell` все еще может отвечать на любой тип запроса клиента.

Для более полного исторического повествования, ведущего к Rholang, см. «Калькулятор мобильных процессов для программирования Blockchain».

.. _Мобильные вычисления процесса для программирования Blockchain: https://docs.google.com/document/d/1lAbB_ssUvUkJ1D6_16WEp4FzsH0poEqZYCi-FBKanuY

.. [#] Lawford, M., Wassyng, A .: Формальная проверка ядерных систем: прошлое, настоящее и будущее. Информация и безопасность: Международный журнал. 28, 223-235 (2012).
.. [#] В дополнение к выбору формально проверяемой модели вычислений изучают несколько рамок проверки, таких как «K-Framework», чтобы достичь этого.
.. _K-Framework: http://www.kframework.org/index.php/Main_Page
.. [#] См. Документацию Scala: Отражение
.. [#] См. Документацию Scala: For-Comprehensions
.. [#] См. Документацию Scala: Ограниченные континуумы
.. [#] См. Документацию по Scala: Case Classes

