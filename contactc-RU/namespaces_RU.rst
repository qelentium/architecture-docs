.. _пространства имен:

************************************************** ***************
Логика пространства имён
************************************************** ***************

Для того, чтобы реализовать  решение интернет-масштаба, оно, как и Интернет, должно обладать логикой рассуждать о «местоположении» ресурса. В частности, как мы ссылаемся на ресурс? Как определить, какие агенты могут получить доступ к этому ресурсу при каких условиях? В отличие от многих других цепочек, где адреса являются плоскими открытыми ключами (или хэшами), виртуальное адресное пространство RChain будет разделено на пространства имен. ** В очень общем объяснении пространство имен представляет собой набор именованных каналов. ** Поскольку каналы довольно часто реализуются как хранилища данных, пространство имен эквивалентно множеству разрешенных ресурсов.

.. sidebar :: Q & A: Пространства имен и двойные расходы

   Q: Предположим, что Алиса, Боб и Кэрол находятся в разных пространствах имен
   и у нас есть два платежа: Алиса-Боб и Алиса-Кэрол. Если я
   узел, который только хочет заботиться о Алисе, как я могу знать, что
   Алиса не тратит вдвое больше?

   A: Пространство имен - это просто набор имен. Все блокчейны
   адреса - это имена. Коллекцию можно описать несколькими способами.
   Один из них является расширенным путем явного описания каждого элемента
   в сборнике. Другой способ заключается в том, чтобы
   правило или программа, которая генерирует коллекцию и распознает
   когда элемент находится в коллекции или из коллекции.
   более интересными пространствами имен являются интенсивно заданные.

   Теперь следующий шаг - связать их с пользователями, контрактами и
   узлами. Оба пользователя и контракты взаимодействуют друг с другом через
   имена. Узлы проверяют транзакции в заданных пространствах имен и
   транзакции - это события ввода / вывода между именами (которые используются как
   каналы ). Любая сделка, которая включает в себя два отдельных
   пространства имен должны обслуживаться набором узлов, которые обрабатывают
   эти пространства имен. Если нет узлов, которые обрабатывают транзакции
   которые объединяют пространства имен, тогда транзакция не может произойти.

   Если есть узлы, которые объединяют пространства имен, то консенсус
   алгоритм гарантирует, что все узлы согласуют транзакции.
   В частности, они согласны с победителями каждой гонки. Таким образом,
   никогда не бывает двойных расходов. Самая большая угроза - найти
   составные пространства имен, которые обслуживаются несколькими валидаторами. К счастью,
   вы можете увидеть полномочия валидатора за пространством имен и решить
   верить этому пространству имен.


Мы установили, что два процесса должны совместно использовать именованный канал для связи, но что, если несколько процессов имеют один и тот же канал? Транзакционный недетерминизм вводится в двух общих условиях, которые делают ресурс спорным и восприимчивым к условиям гонки:

::

                                    для (ptrn <- x) {P1} | x! (@ Q) | для (ptrn <- x) {P2}

Первое условие гонки возникает, когда несколько клиентов в многозадачном составе конкурируют за * получение * ресурса данных по именованному каналу. В этом случае: код: `P1` и: code:` P2`, ждут по указанному каналу: код: `x`, для ресурса: code:` @ Q` отправляется по: code: `x` другим процессом. Клиенты будут выполнять свои продолжения, если и только если в этом месте указано правильное значение. В других случаях, когда многие клиенты конкурируют, многие сокращения могут быть возможны, но в этом случае может возникнуть только один из двух. Один из них: code: `P1` получает: code:` @ Q` first и one где: code: `P2` получает: code:` @ Q` first, оба из которых могут возвращать разные результаты, когда: code: `@Q `подставляется в соответствующие протокольные органы.
Первое условие гонки возникает, когда несколько клиентов в параллельном составе конкурируют за * получение * ресурса данных по именованному каналу. В этом случае: код: `P1` и: code:` P2`, ждут по указанному каналу: код: `x`, для ресурса: code:` @ Q` отправляется по: code: `x` другим процессом. Клиенты будут выполнять свои продолжения, если и только если в этом месте указано правильное значение. В других случаях, когда многие клиенты конкурируют, многие сокращения могут быть возможны, но в этом случае может возникнуть только один из двух. Один из них: code: `P1` получает: code:` @ Q` first и one где: code: `P2` получает: code:` @ Q` first, оба из которых могут возвращать разные результаты, когда: code: `@Q `подставляется в соответствующие протокольные органы.

::

                                          x! (@ Q1) | для (ptrn <- x) {P} | х! (@ Q2)

​                                          
Второе условие гонки возникает, когда два клиента конкурируют за * отправку * ресурса данных по именованному каналу. В этом случае каждый клиент конкурирует за отправку ресурса данных: code: `@ Q` клиенту по указанному каналу: code:` x`, но может произойти только одна из двух транзакций - одна, на которую принимает принимающий клиент : code: `@ Q1` сначала и тот, где он получает: code:` @ Q2`, оба из которых могут возвращать разные результаты при замене в скелет протокола: code: `P`.

Для протоколов, конкурирующих за ресурсы, этот уровень недетерминированности неизбежен. Позже, в разделе о консенсусе, мы опишем, как согласованный алгоритм поддерживает реплицированное состояние, сходясь на одном из многих возможных случаев транзакций в недетерминированном процессе. В настоящее время наблюдайте, как просто переопределить ограничение имени в первом состоянии гонки:

::

            для (ptrn <- x) {P1} | x! (@ Q) | для (ptrn <- v) {P2} → P1 {@ Q / ptrn} | для (ptrn <- v) {P2}

- и второе состояние гонки:
- и второе состояние гонки:

::

                        x! (@ Q1) | для (ptrn <- x) {P} | u! (@ Q2) → P {@ Q1 / ptrn} | у! (@ Q2)

​                            
В обоих случаях канал и передаваемый ресурс данных больше не являются спорными просто потому, что теперь они обмениваются двумя различными именованными каналами. Другими словами, они находятся в отдельных пространствах имен. Кроме того, имена предположительно неопознаны, поэтому их можно получить только тогда, когда им предоставляется дискреционный внешний процесс. Поскольку имя неизвестно, ресурс доступен только для процессов / контрактов, которые знают это имя [5] _. Следовательно, наборы процессов, которые выполняются над неконфликтными наборами именованных каналов, а также наборы транзакций, выполняемых в отдельных пространствах имен, могут выполняться параллельно, как показано ниже:

::

   для (ptrn1 <- x1) {P1} | x1! (@ Q1) | ... | для (ptrnn <- xn) {Pn} | xn! (@ Qn) → P1 {@ Q1 / ptrn1} | ... | Pn {@ Qn / ptrnn}

 | для (ptrn1 <- v1) {P1} | v1! (@ Q1) | ... | для (ptrnn <- vn) {Pn} | vn! (@ Q1) → P1 {@ Q1 / ptrn1} | ... | Pn {@ Qn / ptrnn}


Набор транзакций, выполняемых параллельно в пространстве имен: code: `x`, и набор транзакций, выполняемых в пространстве имен: code:` v`, являются двойными слепыми; они анонимны друг другу, если они не введены вспомогательным процессом. Оба набора транзакций связывают один и тот же ресурс: code: `@ Q` и даже требуют, чтобы: code:` @ Q` соответствовал тому же: code: `ptrn`, но условия гонки не возникают, потому что каждый вывод имеет одну входную встречную часть, а транзакции происходят в отдельных пространствах имен. Такой подход к изоляции наборов процессов / контрактных взаимодействий по существу разделяет адресное пространство RChain во многих независимых транзакционных средах, каждый из которых является внутренне параллельным и может выполняться параллельно друг с другом.


.. figure :: .. /img/blocks-by-namespace.png
    : align: center
    : ширина: 1950
: высота: 1050
    : шкала: 40

    Рисунок - Пространства имен как изолированные транзакционные среды
​    

Тем не менее, в этом представлении факт остается фактом, что ресурсы видны для процессов / контрактов, которые знают название канала и удовлетворяют совпадение шаблонов. После разбиения адресного пространства на мультиизолированные транзакционные среды, как мы дополнительно уточним тип процесса / контракта, который может взаимодействовать с ресурсом в подобной среде? - при каких условиях и в какой степени это возможно? Для этого перейдем к определениям.

Определения пространства имен
================================================== ==========
** Определение пространства имен является формульным описанием минимальных условий, необходимых для функционирования процесса / контракта в пространстве имен. ** На самом деле, согласованность пространства имен непосредственно и зависит от того, как это пространство определяет имя, которые могут сильно варьироваться в зависимости от предполагаемой функции контрактов, описанных в определении пространства имен.

Имя удовлетворяет определению, или нет; он функционирует, или нет. Следующее определение пространства имен реализуется как «если подходит» во взаимодействии, которое отображает набор процессов, отправляющих набор контрактов в набор именованных адресов, которые содержат пространство имен:


.. figure :: .. /img/namespace-definitions.png
    : align: center
    : ширина: 2659
: высота: 1588
    : шкала: 40

    Рисунок - Определение пространства имен Реализовано как «If-conditional»

​    

1. Набор контрактов: code: `contract1 ... contractn`, отправляются на набор каналов (пространство имен): code:` address1 ... addressn`.

2. Параллельно процесс прослушивает вход для каждого канала в пространстве имен: code: `address`.

3. Когда контракт получен по любому из каналов, он предоставляется: code: `if cond.`, который проверяет происхождение пространства имен, адрес отправителя, поведение контракта, структуру контракта, а также размер данных, которые несет контракт.

4. Если эти свойства соответствуют тем, которые обозначены определением пространства имен: code: `address`, продолжение: code:` P` выполняется с: code: `contract` в качестве аргумента.

Определение пространства имен эффективно ограничивает типы взаимодействий, которые могут возникать в пространстве имен - с каждым существующим в пространстве контрактом, демонстрирующим общее и предсказуемое поведение. То есть, изменения состояния, вызванные контрактом, находящимся в пространстве имен, обязательно разрешены, определены и правильны для этого пространства имен. Этот выбор дизайна делает быстрые запросы в стиле каталога в пространстве имен очень удобными и чрезвычайно полезными.

Определение пространства имен может управлять взаимодействиями, происходящими в пространстве, например, путем указания:

* Принятые адреса
* Принятые пространства имен
* Принятые поведенческие типы
* Максимальный/минимальный размер данных
* Структура ввода / вывода

Определение может и часто указывать набор принятых пространств имен и адресов, которые могут связываться с агентами, которые он определяет.

Обратите внимание на проверку типов поведения в приведенном выше графике. Это необходимо для обеспечения того, чтобы последовательность операций, выраженная в контракте, соответствовала спецификации безопасности пространства имен. Поведенческие проверки типов могут оценивать свойства живучести, завершения, взаимоблокировки и синхронизации ресурсов - все свойства, которые обеспечивают максимально «безопасные» изменения состояния ресурсов в пространстве имен. Поскольку поведенческие типы обозначают последовательность операций, критерий поведенческого типа может определять постконвенции контракта, которые, в свою очередь, могут удовлетворять предварительным условиям последующего пространства имен. В результате структура пространства имен поддерживает безопасную композицию или «цепочку» вместе с транзакционными средами.

Составляемые пространства имен - адресация ресурсов
================================================== ===========================
До этого момента мы описали именованные каналы как плоские, атомные объекты произвольной ширины. С отражением и внутренней структурой по именованным каналам мы достигаем глубины.

Пространство имен можно рассматривать как URI (Uniform Resource Identifier), в то время как адрес ресурса можно рассматривать как URL (Uniform Resource Locator). Компонент пути URL,: code: `scheme: // a / b / c`, например, может рассматриваться как эквивалентный адресу RChain. То есть, ряд вложенных каналов, каждый из которых принимает сообщения с именованным каналом: code: `a`, являющийся« верхним »каналом.

Однако обратите внимание, что пути URL не всегда составляют. Возьмите код: `схема: // a / b / c` и: code:` схема: // a / b / d`. В традиционной схеме URL-адреса эти две команды не создают путь. Однако каждый плоский путь автоматически представляет собой путь к дереву, и, как деревья, они дают корни новому дереву: code: `scheme: // a / b / c + d`. Таким образом, деревья предоставляют композиционную модель для адресации ресурсов.


.. figure :: .. /img/namespaces-as-tree-paths.png
    : align: center
    : ширина: 1617
    : шкала: 40
    
    Рисунок - Композитные контуры деревьев

Выше унификация работает как естественный алгоритм для сопоставления и разложения деревьев, а объединение и декомпозиция на основе унификации обеспечивают основу запроса. Чтобы изучить эту заявку, перепишем наш синтаксис path / tree в этой форме:
Выше унификация работает как естественный алгоритм для сопоставления и разложения деревьев, а объединение и декомпозиция на основе унификации обеспечивают основу запроса. Чтобы изучить эту заявку, перепишем наш синтаксис path / tree в этой форме:

::

 схема: // a / b / c + d ↦ s: a (b (c, d))


Затем адаптируйте синтаксис к действиям ввода-вывода rho-исчисления:

::

                                                      s (a (b (c, d)))
    
                                                      для (a (b (c, d)) <- s, если cond) {P}

​          
Верхнее выражение обозначает вывод - поместите адрес ресурса: code: `a (b (c, d)` на именованный канал: code: `s`. Нижнее выражение обозначает ввод. Для шаблона, который соответствует форме: code: `a (b (c, d))`, входящий в канал: code: `s`, если выполнено какое-то предварительное условие, выполните продолжение: code:` P`, с адресом: code: `a (b (c , d) `в качестве аргумента. Конечно, это выражение подразумевает: code:` s`, как именованный канал, поэтому представлена ​​адаптированная структура канала:


.. figure :: .. /img/namespaces-as-trees.png
    : align: center
    : ширина: 567
    : шкала: 40
    
    Рисунок - Схема URL как вложенные каналы в структуре дерева

Учитывая существующую структуру адресов и доступ к пространству имен, клиент может запрашивать и отправлять имена в пределах этой структуры адресов. Например, когда процессы ввода-вывода rho-calculus помещаются в параллельное выполнение, следующее выражение обозначает функцию, которая помещает цитируемые процессы: code: `(@ Q, @ R)` в местоположение,: code: ` а (Ь (в, г)) `:
Учитывая существующую структуру адресов и доступ к пространству имен, клиент может запрашивать и отправлять имена в пределах этой структуры адресов. Например, когда процессы ввода-вывода rho-calculus помещаются в параллельное выполнение, следующее выражение обозначает функцию, которая помещает цитируемые процессы: code: `(@ Q, @ R)` в местоположение,: code: ` а (Ь (в, г)) `:

::

                                            для (a (b (c, d)) <- s, если cond) {P} | s (a (b (@ Q, @ R)))

Шаг оценки написан символически:
Шаг оценки написан символически:

::

                                   для (a (b (c, d)) <- s, если cond) {P} | s! (a (b (@ Q, @ R))) → P {@Q: = c, @R: = d}

То есть: code: `P` выполняется в среде, в которой: code:` c` заменяется на: code: `@ Q` и: code:` d` заменяется на: code: `@ R` , Обновленная древовидная структура представлена ​​следующим образом:
То есть: code: `P` выполняется в среде, в которой: code:` c` заменяется на: code: `@ Q` и: code:` d` заменяется на: code: `@ R` , Обновленная древовидная структура представлена ​​следующим образом:


.. figure :: .. /img/tree-structure-substoded.png
    : align: center
    : ширина: 1688
    : шкала: 30
    
    Рисунок - Размещение процессов на каналах

В дополнение к плоскому набору каналов, например: code: `s1 ... sn`, квалифицирующийся как пространство имен, каждый канал с внутренней структурой сам по себе является пространством имен. Поэтому: code: `s`,: code:` a` и: code: `b` могут постепенно налагать отдельные определения пространства имен, аналогичные тем, которые заданы плоским пространством имен. На практике внутренняя структура именованного канала представляет собой n-арное дерево произвольной глубины и сложности, где «верхний» канал, в данном случае: code: `s`, является одним из многих возможных имен в: code:` s1 ... sn`, которые обладают внутренней структурой.
В дополнение к плоскому набору каналов, например: code: `s1 ... sn`, квалифицирующийся как пространство имен, каждый канал с внутренней структурой сам по себе является пространством имен. Поэтому: code: `s`,: code:` a` и: code: `b` могут постепенно налагать отдельные определения пространства имен, аналогичные тем, которые заданы плоским пространством имен. На практике внутренняя структура именованного канала представляет собой n-арное дерево произвольной глубины и сложности, где «верхний» канал, в данном случае: code: `s`, является одним из многих возможных имен в: code:` s1 ... sn`, которые обладают внутренней структурой.

Эта структура адресации ресурсов представляет собой поэтапную адаптацию к тому, что является наиболее широко используемым стандартом интернет-адресации в истории. RChain достигает адресного пространства композиций, необходимого для видимости частного, общественного и консорциума в пространстве имен, но очевидный прецедент использует масштабируемость. Не случайно, и неудивительно, что пространства имен также предлагают основу для решения Sharding от RChain.


.. [5] Логика пространства имен - логика для рефлексивного исчисления высших порядков.


